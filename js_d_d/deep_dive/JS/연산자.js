/* 표현식의 역할 - 값을 생성
   문의 역할 - 표현식으로 생성한 값을 사용해 컴퓨터에게 명령 
   선언문은 값으로 평가 x, 따라서 표현식이 아니라 문이다.
   but, 할당문은 그 자체가 표현시인 문이다. */

   // 선언문
   var x = 5 * 10; // 표현식 x = 5 * 10을 포함하는 문 -> 값으로 평가 x

   // 할당문
   x = 100; // 이 자체가 표현식 and 완전한 문

var foo = x = 100; // 할당문을 값처럼 변수에 할당. 할당문은 할당한 값으로 평가된다. 즉, x = 100은 변수 x에 할당한 값 100으로 평가


/* 연산자 - 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입 연산 등을 수행해 하나의 값을 만드는 것 */

// 5 * 4

// 'My name is ' + 'Lee'

// var color = 'red';

// 3 > 5

// (5 > 3) && (2 < 4)

// typeof 'Hi'


/* 피연산자가 “값”이라는 명사의 역할을 한다면 연산자는 “값을 만든다”라는 동사의 역할을 한다고 볼 수 있다. 다시 말해, 피연산자는 연산의 대상이 되어야 하므로 값으로 평가할 수 있어야 한다. 연산자는 값으로 평가된 피연산자를 연산해 새로운 값을 만든다. */

/* 산술 연산자 - 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다. 산술 연산을 할 수 없는 경우에는 NaN을 반환 */


var x;
console.log(x = 10); 
/* 할당 연산은 변수에 값을 할당하는 부수 효과만 있을 뿐 값으로 평가되지 않을 것처럼 보인다. 하지만 할당 연산은 하나의 값으로 평가되는 표현식이다. 할당 표현식은 할당된 값으로 평가된다. 위 예제의 경우 x에 할당된 숫자 값 10으로 평가된다 */

var x, y;
y = x = 10; // 연쇄 할당
console.log(x, y);  // 10, 10


NaN === NaN // false
/* NaN은 자신과 일치하지 않는 유일한 값이다. 따라서 숫자가 NaN인지 조사하려면 빌트인 함수 isNaN을 사용한다 */
isNaN(NaN)  // true /

console.log(isNaN(NaN));
console.log(isNaN(3)); // 숫자일 경우flase 반환

console.log(0 === -0);


/* 조건식 ? 조건식이 ture일때 반환할 값 : 조건식이 false일때 반환할 값 
 불리언 타입의 값으로 평가될 표현식 ? true 반환 값 : false 반환 값 
 만약 평가 결과가 불리언 값이 아니면 불리언 값으로 암묵적 타입 변환된다. */
 /* 따라서 삼항 조건 연산자식은 다른 표현식의 일부가 될 수 있어 매우 유용하다. */


 /* 논리 연산자 - 논리 부정(!) 연산자는 언제나 불리언 값을 반환한다. 하지만 논리합(||) 연산자와 논리곱(&&) 연산자는 일반적으로 불리언 값을 반환하지만 반드시 불리언 값을 반환해야 하는 것은 아니다. */


 /* 쉼표 연산자 - 쉼표(,) 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환 */


 /* 그룹 연산자 - 그룹 ((…))연산자는 그룹 내의 표현식을 최우선으로 평가 */

 10 * 2 + 3   // 23
10 * (2 + 3) // 50


/* typeof 연산자 - 자신의 뒤에 위치한 피연산자의 데이터 타입을 문자열로 반환
null을 반환하는 경우는 없으며 함수의 경우 function을 반환한다.
- typeof null // object */


var foo = null;
console.log(typeof foo === null); // false
console.log(foo === null);        // true